#! /usr/bin/env python
#
# Copyright (C) 2012 Lorne Liechty
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import config
import subcmds
import sys
import os.path
import subprocess_helper
import utils 

GHI_VERSION = "0.4.0"
def printVersion():
    print "ghi version " + GHI_VERSION
    
# First, check to see if we are even in a git repository...
if str(config.GIT_ROOT).count("fatal: Not a git repository"):
    print "Not a git repository! ghi commands must be run within a git!"
    quit()

# Now check to see if we've got ghi installed in this repository...
if not sys.argv.count(subcmds.init.NAME) and (
    os.path.isdir(config.GHI_DIR) == False or 
    os.path.isdir(config.ISSUES_DIR) == False or 
    os.path.isdir(config.GROUPS_DIR) == False):
    print "ghi not yet initialized in this repository. Please run ghi-init."
    quit()

# Create top-level argument parser
parser = argparse.ArgumentParser()

# Give people a way to get the version of ghi that they are working with
parser.add_argument("--version", action="store_true",
                    help="Display the version of the ghi install")

cmds = parser.add_subparsers(title="subcommands",
                             help="valid subcommands")

# Create the various subcmd parsers
subcmds.init  .Args.addCmdToParser(cmds)
subcmds.ls    .Args.addCmdToParser(cmds)
subcmds.add   .Args.addCmdToParser(cmds)
subcmds.edit  .Args.addCmdToParser(cmds)
subcmds.rm    .Args.addCmdToParser(cmds)
subcmds.group .Args.addCmdToParser(cmds)

# Quick sanity check to see if any subcommand was given at all
knownCmd = False
cmd_names = [
    subcmds.add.NAME,
    subcmds.edit.NAME,
    subcmds.group.NAME,
    subcmds.init.NAME,
    subcmds.ls.NAME,
    subcmds.rm.NAME
    ]
for i, arg in enumerate(sys.argv):
    if (i != 0 and str(arg)[0] != '-'):
        if cmd_names.count(arg) > 0:
            knownCmd = True
            break

optarg = False
if len(sys.argv) > 1:
    if not (sys.argv.count("-h") or sys.argv.count("--help") or 
            sys.argv.count("--version")):
        optarg = True

# Make the default subcommand 'ls'
xcmd = None
if (knownCmd == False):
    # If our passed-in arguments didn't contain a known command, then
    # there may have been a valid extension command
    if sys.argv[0].count("ghi"):
        xcmd = "ghi-" + sys.argv[1]
        if which(xcmd) == None:
            if optarg:
                args = parser.parse_args(sys.argv.insert(1,subcmds.ls.NAME))
            else:
                args = parser.parse_args(sys.argv.extend([subcmds.ls.NAME]))
else:
    args = parser.parse_args()

if xcmd:
    # Execute the extension command
    cmdStatus = os.system(xcmd + ' ' + ' '.join(sys.argv[2:]))
    if cmdStatus == 0:
        # Looks like the command executed successfully...
        quit()

elif (args.version):
    # Just display the version info
    printVersion()

else:
    # Execute the command
    args.func(args)
